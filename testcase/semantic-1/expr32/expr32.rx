/*
Test Package: Semantic-1
Test Target: expr
Author: Wenxin Zheng
Time: 2025-08-08
Verdict: Fail
Comment: Complex expression error: Missing closing parenthesis in function call - recursive fibonacci with memoization, binary tree operations, and complex nested expressions
*/

struct BinaryTreeNode {
    value: i32,
    left_child: bool,
    right_child: bool,
}

impl BinaryTreeNode {
    fn new(val: i32) -> BinaryTreeNode {
        BinaryTreeNode {
            value: val,
            left_child: false,
            right_child: false,
        }
    }
}

fn fibonacci_tree_height(n: i32, mut memo: [i32; 20]) -> i32 {
    if (n <= 1) {
        return n;
    }
    
    if (memo[n] != -1) {
        return memo[n];
    }
    
    let left_height: i32 = fibonacci_tree_height(n - 1, memo);
    let right_height: i32 = fibonacci_tree_height(n - 2, memo);
    
    let current_height: i32 = {
        let temp_sum: i32 = left_height + right_height;
        let normalized: i32 = temp_sum % 100;
        if (normalized > 50) {
            normalized - 25
        } else {
            normalized + 10
        }
    };
    
    memo[n] = current_height;
    return current_height;
}

fn calculate_tree_complexity(nodes: [BinaryTreeNode; 5]) -> i32 {
    let mut total_complexity: i32 = 0;
    let mut index: usize = 0;
    
    loop {
        if (index >= 5) {
            break;
        }
        
        let node: &BinaryTreeNode = &nodes[index];
        let node_value: i32 = node.value;
        let complexity_factor: i32 = {
            let base: i32 = node_value * node_value;
            let modifier: i32 = if (node.left_child) { 2 } else { 1 };
            let adjusted: i32 = base * modifier;
            if (node.right_child) {
                adjusted + 5
            } else {
                adjusted - 3
            }
        };
        
        total_complexity = total_complexity + complexity_factor;
        index = index + 1;
    }
    
    return total_complexity;
}

fn main() {
    let mut memo_array: [i32; 20] = [-1; 20];
    let mut tree_nodes: [BinaryTreeNode; 5] = [
        BinaryTreeNode::new(1),
        BinaryTreeNode::new(3),
        BinaryTreeNode::new(5),
        BinaryTreeNode::new(7),
        BinaryTreeNode::new(9),
    ];
    
    tree_nodes[0].left_child = true;
    tree_nodes[0].right_child = false;
    tree_nodes[1].left_child = true;
    tree_nodes[1].right_child = true;
    tree_nodes[2].left_child = false;
    tree_nodes[2].right_child = true;
    tree_nodes[3].left_child = true;
    tree_nodes[3].right_child = true;
    tree_nodes[4].left_child = false;
    tree_nodes[4].right_child = false;
    
    let fib_result: i32 = fibonacci_tree_height(8, memo_array);
    let complexity_result: i32 = calculate_tree_complexity(tree_nodes);
    
    let combined_result: i32 = {
        let weighted_fib: i32 = fib_result * 3;
        let weighted_complexity: i32 = complexity_result / 2;
        let sum: i32 = weighted_fib + weighted_complexity;
        if (sum > 100) {
            sum % 50
        } else {
            sum * 2
        }
    };
    
    let final_output: i32 = if (combined_result > 0) {
        let temp: i32 = combined_result + 1;
        if (temp % 2 == 0) {
            temp / 2
        } else {
            temp * 3 + 1
        }
    } else {
        42
    };
    
    if (final_output != 0 && final_output > 0) {
        printInt(final_output;
    } else {
        printInt(0);
    }
    exit(0);
}
