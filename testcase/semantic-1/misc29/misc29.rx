/*
Test Package: Semantic-1
Test Target: misc
Author: Wenxin Zheng
Time: 2025-08-08
Verdict: Success
Comment: Fenwick Tree (Binary Indexed Tree) for efficient range queries
*/

// Fenwick Tree (Binary Indexed Tree) for efficient range queries
// Supports point updates and prefix sum queries in O(log n) time
struct FenwickTree {
    tree: [i32; 1001], // 1-indexed array
    n: i32,
}

impl FenwickTree {
    fn new(size: i32) -> FenwickTree {
        FenwickTree {
            tree: [0; 1001],
            n: size,
        }
    }
    
    fn update(&mut self, idx: i32, delta: i32) {
        let mut index: i32 = idx + 1; // Convert to 1-indexed
        while (index <= self.n) {
            self.tree[index as usize] += delta;
            index += index & (-index); // Add LSB
        }
    }
    
    fn prefix_sum(&self, idx: i32) -> i32 {
        let mut sum: i32 = 0;
        let mut index: i32 = idx + 1; // Convert to 1-indexed
        
        while (index > 0) {
            sum += self.tree[index as usize];
            index -= index & (-index); // Remove LSB
        }
        
        return sum;
    }
    
    fn range_sum(&self, left: i32, right: i32) -> i32 {
        if (left > right) {
            return 0;
        }
        
        if (left == 0) {
            return self.prefix_sum(right);
        } else {
            return self.prefix_sum(right) - self.prefix_sum(left - 1);
        }
    }
    
    fn init_from_array(&mut self, arr: &[i32]) {
        let mut i: i32 = 0;
        while (i < self.n) {
            self.update(i, arr[i as usize]);
            i += 1;
        }
    }
    
    fn point_query(&self, idx: i32) -> i32 {
        return self.range_sum(idx, idx);
    }
    
    fn set_value(&mut self, idx: i32, new_val: i32) {
        let current_val: i32 = self.point_query(idx);
        let delta: i32 = new_val - current_val;
        self.update(idx, delta);
    }
}

// 2D Fenwick Tree for 2D range queries
struct FenwickTree2D {
    tree: [[i32; 101]; 101],
    rows: i32,
    cols: i32,
}

impl FenwickTree2D {
    fn new(rows: i32, cols: i32) -> FenwickTree2D {
        FenwickTree2D {
            tree: [[0; 101]; 101],
            rows: rows,
            cols: cols,
        }
    }
    
    fn update(&mut self, row: i32, col: i32, delta: i32) {
        let mut r: i32 = row + 1; // Convert to 1-indexed
        while (r <= self.rows) {
            let mut c: i32 = col + 1;
            while (c <= self.cols) {
                self.tree[r as usize][c as usize] += delta;
                c += c & (-c);
            }
            r += r & (-r);
        }
    }
    
    fn prefix_sum(&self, row: i32, col: i32) -> i32 {
        let mut sum: i32 = 0;
        let mut r: i32 = row + 1;
        
        while (r > 0) {
            let mut c: i32 = col + 1;
            while (c > 0) {
                sum += self.tree[r as usize][c as usize];
                c -= c & (-c);
            }
            r -= r & (-r);
        }
        
        return sum;
    }
    
    fn range_sum(&self, row1: i32, col1: i32, row2: i32, col2: i32) -> i32 {
        return self.prefix_sum(row2, col2) 
               - self.prefix_sum(row1 - 1, col2) 
               - self.prefix_sum(row2, col1 - 1) 
               + self.prefix_sum(row1 - 1, col1 - 1);
    }
}

// Range Update Fenwick Tree using difference array
struct RangeUpdateFenwick {
    tree: [i32; 1001],
    n: i32,
}

impl RangeUpdateFenwick {
    fn new(size: i32) -> RangeUpdateFenwick {
        RangeUpdateFenwick {
            tree: [0; 1001],
            n: size,
        }
    }
    
    fn update_range(&mut self, left: i32, right: i32, delta: i32) {
        self.update_point(left, delta);
        self.update_point(right + 1, -delta);
    }
    
    fn update_point(&mut self, idx: i32, delta: i32) {
        let mut index: i32 = idx + 1;
        while (index <= self.n) {
            self.tree[index as usize] += delta;
            index += index & (-index);
        }
    }
    
    fn query(&self, idx: i32) -> i32 {
        let mut sum: i32 = 0;
        let mut index: i32 = idx + 1;
        
        while (index > 0) {
            sum += self.tree[index as usize];
            index -= index & (-index);
        }
        
        return sum;
    }
}

// Fenwick Tree with range updates and range queries
struct LazyFenwick {
    tree1: [i32; 1001], // For coefficient of (i+1)
    tree2: [i32; 1001], // For constant term
    n: i32,
}

impl LazyFenwick {
    fn new(size: i32) -> LazyFenwick {
        LazyFenwick {
            tree1: [0; 1001],
            tree2: [0; 1001],
            n: size,
        }
    }
    
    fn update_tree(n:i32, tree: &mut [i32; 1001], idx: i32, delta: i32) {
        let mut index = idx + 1;
        while (index <= n) {
            tree[index as usize] += delta;
            index += index & (-index);
        }
    }
    
    fn query_tree(&self, tree: &[i32; 1001], idx: i32) -> i32 {
        let mut sum: i32 = 0;
        let mut index: i32 = idx + 1;
        
        while (index > 0) {
            sum += tree[index as usize];
            index -= index & (-index);
        }
        
        return sum;
    }
    
    fn range_update(&mut self, left: i32, right: i32, delta: i32) {
        Self::update_tree(self.n, &mut self.tree1, left, delta);
        Self::update_tree(self.n, &mut self.tree1, right + 1, -delta);
        Self::update_tree(self.n, &mut self.tree2, left, delta * (left - 1));
        Self::update_tree(self.n, &mut self.tree2, right + 1, -delta * right);
    }
    
    fn prefix_query(&self, idx: i32) -> i32 {
        return self.query_tree(&self.tree1, idx) * idx - self.query_tree(&self.tree2, idx);
    }
    
    fn range_query(&self, left: i32, right: i32) -> i32 {
        return self.prefix_query(right + 1) - self.prefix_query(left);
    }
}

fn main() {
    let n: i32 = getInt();
    let mut fenwick: FenwickTree = FenwickTree::new(n);
    
    // Initialize array
    let mut arr: [i32; 1000] = [0; 1000];
    let mut i: i32 = 0;
    while (i < n) {
        arr[i as usize] = getInt();
        i += 1;
    }
    fenwick.init_from_array(&arr);
    
    let queries: i32 = getInt();
    i = 0;
    
    while (i < queries) {
        let operation: i32 = getInt();
        
        if (operation == 1) { // Point update
            let idx: i32 = getInt();
            let val: i32 = getInt();
            fenwick.set_value(idx, val);
        } else if (operation == 2) { // Range sum query
            let left: i32 = getInt();
            let right: i32 = getInt();
            let sum: i32 = fenwick.range_sum(left, right);
            printInt(sum);
        } else if (operation == 3) { // Prefix sum query
            let idx: i32 = getInt();
            let sum: i32 = fenwick.prefix_sum(idx);
            printInt(sum);
        } else if (operation == 4) { // Point query
            let idx: i32 = getInt();
            let val: i32 = fenwick.point_query(idx);
            printInt(val);
        }
        i += 1;
    }
    exit(0);
}
