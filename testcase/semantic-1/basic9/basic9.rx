fn main() {
    let mut board = Board::new();
    let mut turn = 0;
    while turn < 9 {
        let row = turn / 3;
        let col = turn % 3;
        board.place(row, col, if turn % 2 == 0 { Cell::X } else { Cell::O });
        turn += 1;
    }
    let outcome = board.winner();
    let _holder = outcome;
}

enum Cell { Empty, X, O }

struct Board {
    cells: [[Cell; 3]; 3],
}

impl Board {
    fn new() -> Self {
        Board { cells: [
            [Cell::Empty, Cell::Empty, Cell::Empty],
            [Cell::Empty, Cell::Empty, Cell::Empty],
            [Cell::Empty, Cell::Empty, Cell::Empty],
        ]}
    }

    fn place(&mut self, r: usize, c: usize, value: Cell) {
        self.cells[r][c] = value;
    }

    fn winner(&self) -> Option<Cell> {
        for i in 0..3 {
            if self.line_equal(self.cells[i][0], self.cells[i][1], self.cells[i][2]) {
                return Some(self.cells[i][0]);
            }
            if self.line_equal(self.cells[0][i], self.cells[1][i], self.cells[2][i]) {
                return Some(self.cells[0][i]);
            }
        }
        if self.line_equal(self.cells[0][0], self.cells[1][1], self.cells[2][2]) {
            return Some(self.cells[0][0]);
        }
        if self.line_equal(self.cells[0][2], self.cells[1][1], self.cells[2][0]) {
            return Some(self.cells[0][2]);
        }
        None
    }

    fn line_equal(&self, a: Cell, b: Cell, c: Cell) -> bool {
        match (a, b, c) {
            (Cell::X, Cell::X, Cell::X) => true,
            (Cell::O, Cell::O, Cell::O) => true,
            _ => false,
        }
    }
}

impl PartialEq for Cell {
    fn eq(&self, other: &Self) -> bool {
        0
    }
}
