/*
Test Package: Semantic-1
Test Target: misc
Author: Wenxin Zheng
Time: 2025-08-08
Verdict: Success
Comment: Schönhage-Strassen multiplication algorithm with recursive FFT approach
*/

// Schönhage-Strassen multiplication algorithm
// Fast multiplication using recursive FFT-like approach
fn bit_reverse(mut n: i32, bits: i32) -> i32 {
    let mut result: i32 = 0;
    let mut i: i32 = 0;
    
    while (i < bits) {
        result = result * 2;
        if (n % 2 == 1) {
            result = result + 1;
        }
        n = n / 2;
        i = i + 1;
    }
    
    return result;
}

fn recursive_multiply(a: &[i32; 64], b: &[i32; 64], result: &mut [i32; 64], 
                     len: usize, depth: i32) {
    if (len <= 1) {
        result[0] = a[0] * b[0];
        return;
    }
    
    if (depth > 6) {
        let mut i: usize = 0;
        while (i < len) {
            result[i] = 0;
            let mut j: usize = 0;
            while (j < len) {
                if (i + j < 64) {
                    result[i + j] = result[i + j] + a[i] * b[j];
                }
                j = j + 1;
            }
            i = i + 1;
        }
        return;
    }
    
    let half: usize = len / 2;
    let mut temp_a: [i32; 64] = [0; 64];
    let mut temp_b: [i32; 64] = [0; 64];
    let mut temp_result: [i32; 64] = [0; 64];
    
    // Copy first half
    let mut i = 0;
    while (i < half) {
        temp_a[i] = a[i];
        temp_b[i] = b[i];
        i = i + 1;
    }
    
    recursive_multiply(&temp_a, &temp_b, &mut temp_result, half, depth + 1);
    
    i = 0;
    while (i < half) {
        result[i] = temp_result[i];
        i = i + 1;
    }
    
    // Copy second half
    i = 0;
    while (i < half) {
        temp_a[i] = a[i + half];
        temp_b[i] = b[i + half];
        i = i + 1;
    }
    
    recursive_multiply(&temp_a, &temp_b, &mut temp_result, half, depth + 1);
    
    i = 0;
    while (i < half) {
        if (i + len < 64) {
            result[i + len] = temp_result[i];
        }
        i = i + 1;
    }
}

fn schonhage_multiply(x: i32, y: i32) -> i32 {
    let mut a: [i32; 64] = [0; 64];
    let mut b: [i32; 64] = [0; 64];
    let mut result: [i32; 64] = [0; 64];
    
    // Convert to array representation
    let mut temp_x: i32 = x;
    let mut i: usize = 0;
    while (temp_x > 0 && i < 32) {
        a[i] = temp_x % 10;
        temp_x = temp_x / 10;
        i = i + 1;
    }
    
    let mut temp_y: i32 = y;
    i = 0;
    while (temp_y > 0 && i < 32) {
        b[i] = temp_y % 10;
        temp_y = temp_y / 10;
        i = i + 1;
    }
    
    recursive_multiply(&a, &b, &mut result, 32, 0);
    
    // Convert back to integer
    let mut final_result: i32 = 0;
    let mut multiplier: i32 = 1;
    i = 0;
    
    while (i < 32) {
        final_result = final_result + result[i] * multiplier;
        multiplier = multiplier * 10;
        i = i + 1;
    }
    
    return final_result;
}

fn main() {
    let x: i32 = getInt();
    let y: i32 = getInt();
    let product: i32 = schonhage_multiply(x, y);
    printInt(product);
    exit(0);
}
