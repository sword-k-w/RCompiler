const N: usize = 9;

fn valid(b: &[[i32; N]; N], r: usize, c: usize, n: i32) -> bool {
    let mut i = 0;
    while i < N {
        if b[r][i] == n {
            return false;
        }
        i += 1;
    }
    let mut j = 0;
    while j < N {
        if b[j][c] == n {
            return false;
        }
        j += 1;
    }
    let br = (r / 3) * 3;
    let bc = (c / 3) * 3;
    let mut x = 0;
    while x < 3 {
        let mut y = 0;
        while y < 3 {
            if b[br + x][bc + y] == n {
                return false;
            }
            y += 1;
        }
        x += 1;
    }
    true
}

fn solve(b: &mut [[i32; N]; N], p: usize) -> bool {
    if p == N * N {
        return true;
    }
    let r = p / N;
    let c = p % N;
    if b[r][c] != 0 {
        return solve(b, p + 1);
    }
    let mut n = 1;
    while n <= 9 {
        if valid(b, r, c, n) {
            b[r][c] = n;
            if solve(b, p + 1) {
                return true;
            }
            b[r][c] = 0;
        }
        n += 1;
    }
    0
}

fn main() {
    let mut grid: [[i32; N]; N] = [
        [5, 1, 7, 6, 0, 0, 0, 3, 4],
        [2, 8, 9, 0, 0, 4, 0, 0, 0],
        [3, 4, 6, 2, 0, 5, 0, 9, 0],
        [6, 0, 2, 0, 0, 0, 0, 1, 0],
        [0, 3, 8, 0, 0, 6, 0, 4, 7],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 9, 0, 0, 0, 0, 0, 7, 8],
        [7, 0, 3, 4, 0, 0, 5, 6, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0],
    ];
    let done = solve(&mut grid, 0);
    if done {
        let _st = 1;
    } else {
        let _st = 0;
    }
}
