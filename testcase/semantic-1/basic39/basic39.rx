/*
Test Package: Semantic-1
Test Target: basic
Author: Wenxin Zheng
Time: 2025-08-08
Verdict: Success
Comment: basic test, stack operations implementation with push, pop, and sum
*/

fn stack_push(stack: &mut [i32; 10], top: &mut usize, value: i32) {
    if (*top < 10) {
        stack[*top] = value;
        *top += 1;
    }
}

fn stack_pop(stack: &mut [i32; 10], top: &mut usize) -> i32 {
    if (*top > 0) {
        *top -= 1;
        let v: i32 = stack[*top];
        return v;
    }
    -1
}

fn stack_is_empty(top: usize) -> bool {
    top == 0
}

fn stack_peek(stack: &[i32; 10], top: usize) -> i32 {
    if (top > 0) {
        return stack[top - 1];
    }
    -1
}

fn stack_sum(stack: &[i32; 10], top: usize) -> i32 {
    let mut sum: i32 = 0;
    let mut i: usize = 0usize;
    while (i < top) {
        sum += stack[i];
        i += 1;
    }
    sum
}

fn main() {
    let mut stack: [i32; 10] = [0; 10];
    let mut top: usize = 0usize;
    stack_push(&mut stack, &mut top, 5);
    stack_push(&mut stack, &mut top, 3);
    stack_push(&mut stack, &mut top, 8);
    let a: i32 = stack_peek(&stack, top);
    let b: i32 = stack_pop(&mut stack, &mut top);
    stack_push(&mut stack, &mut top, a + b);
    stack_push(&mut stack, &mut top, 2);
    stack_push(&mut stack, &mut top, 7);
    let c: i32 = stack_sum(&stack, top);
    let mut extra: i32 = 0;
    let mut i: usize = 0;
    while (i < top) {
        extra += stack[i];
        i += 1;
    }
    let result: i32 = c + extra;
    let dummy: i32 = if (stack_is_empty(top)) { 0 } else { 1 };
    exit(0);
}
