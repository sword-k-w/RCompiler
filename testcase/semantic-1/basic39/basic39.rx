fn stack_push(stack: &mut [i32; 10], top: &mut usize, value: i32) {
    if *top < 10 {
        stack[*top] = value;
        *top += 1;
    }
}

fn stack_pop(stack: &mut [i32; 10], top: &mut usize) -> i32 {
    if *top > 0 {
        *top -= 1;
        let v = stack[*top];
        return v;
    }
    -1
}

fn stack_is_empty(top: usize) -> bool {
    top == 0
}

fn stack_peek(stack: &[i32; 10], top: usize) -> i32 {
    if top > 0 {
        return stack[top - 1];
    }
    -1
}

fn stack_sum(stack: &[i32; 10], top: usize) -> i32 {
    let mut sum = 0;
    let mut i = 0usize;
    while i < top {
        sum += stack[i];
        i += 1;
    }
    sum
}

fn main() {
    let mut stack: [i32; 10] = [0; 10];
    let mut top = 0usize;
    stack_push(&mut stack, &mut top, 5);
    stack_push(&mut stack, &mut top, 3);
    stack_push(&mut stack, &mut top, 8);
    let a = stack_peek(&stack, top);
    let b = stack_pop(&mut stack, &mut top);
    stack_push(&mut stack, &mut top, a + b);
    stack_push(&mut stack, &mut top, 2);
    stack_push(&mut stack, &mut top, 7);
    let c = stack_sum(&stack, top);
    let mut extra = 0;
    let mut i = 0;
    while i < top {
        extra += stack[i];
        i += 1;
    }
    let _result = c + extra;
    let _dummy = if stack_is_empty(top) { 0 } else { 1 };
}
