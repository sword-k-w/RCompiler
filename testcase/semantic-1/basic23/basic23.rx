type Board = [[u8; 4]; 4];
fn is_safe(b: &Board, row: usize, col: usize, num: u8) -> bool {
    let mut i = 0;
    while i < 4 {
        if b[row][i] == num || b[i][col] == num {
            return false;
        }
        i += 1;
    }
    let start_row = row / 2 * 2;
    let start_col = col / 2 * 2;
    let mut r = 0;
    while r < 2 {
        let mut c = 0;
        while c < 2 {
            if b[start_row + r][start_col + c] == num {
                return false;
            }
            c += 1;
        }
        r += 1;
    }
    true
}
fn solve(b: &mut Board, row: usize, col: usize) -> bool {
    if row == 4 {
        return true;
    }
    let next_row = if col == 3 { row + 1 } else { row };
    let next_col = if col == 3 { 0 } else { col + 1 };
    if b[row][col] != 0 {
        return solve(b, next_row, next_col);
    }
    let mut num = 1u8;
    while num <= 4 {
        if is_safe(b, row, col, num) {
            b[row][col] = num;
            if solve(b, next_row, next_col) {
                return true;
            }
            b[row][col] = 0;
        }
        num += 1;
    }
    false
}
fn main() {
    let mut board: Board = [
        [1, 0, 0, 4],
        [0, 0, 3, 0],
        [0, 3, 0, 0],
        [2, 0, 0, 1],
    ];
    let _solved = solve(&mut board, 0, 0);
}
