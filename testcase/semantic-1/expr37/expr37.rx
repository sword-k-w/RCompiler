/*
Test Package: Semantic-1
Test Target: expr
Author: Wenxin Zheng
Time: 2025-08-08
Verdict: Fail
Comment: Complex expression error: Array length mismatch - segment tree with lazy propagation, range updates, and complex query processing
*/

struct SegmentTreeNode {
    left_bound: i32,
    right_bound: i32,
    sum: i32,
    max_value: i32,
    min_value: i32,
    lazy_add: i32,
    lazy_set: i32,
    has_lazy_set: bool,
}

impl SegmentTreeNode {
    fn new(left: i32, right: i32) -> SegmentTreeNode {
        SegmentTreeNode {
            left_bound: left,
            right_bound: right,
            sum: 0,
            max_value: 0,
            min_value: 0,
            lazy_add: 0,
            lazy_set: 0,
            has_lazy_set: false,
        }
    }
    
    fn push_lazy_to_children(&mut self, left_child: &mut SegmentTreeNode, right_child: &mut SegmentTreeNode) {
        if (self.has_lazy_set) {
            let range_size: i32 = self.right_bound - self.left_bound + 1;
            self.sum = self.lazy_set * range_size;
            self.max_value = self.lazy_set;
            self.min_value = self.lazy_set;
            
            left_child.lazy_set = self.lazy_set;
            left_child.has_lazy_set = true;
            left_child.lazy_add = 0;
            
            right_child.lazy_set = self.lazy_set;
            right_child.has_lazy_set = true;
            right_child.lazy_add = 0;
            
            self.lazy_set = 0;
            self.has_lazy_set = false;
        }
        
        if (self.lazy_add != 0) {
            let range_size: i32 = self.right_bound - self.left_bound + 1;
            self.sum = self.sum + (self.lazy_add * range_size);
            self.max_value = self.max_value + self.lazy_add;
            self.min_value = self.min_value + self.lazy_add;
            
            if (left_child.has_lazy_set) {
                left_child.lazy_set = left_child.lazy_set + self.lazy_add;
            } else {
                left_child.lazy_add = left_child.lazy_add + self.lazy_add;
            }
            
            if (right_child.has_lazy_set) {
                right_child.lazy_set = right_child.lazy_set + self.lazy_add;
            } else {
                right_child.lazy_add = right_child.lazy_add + self.lazy_add;
            }
            
            self.lazy_add = 0;
        }
    }
    
    fn merge_from_children(&mut self, left_child: &SegmentTreeNode, right_child: &SegmentTreeNode) {
        self.sum = left_child.sum + right_child.sum;
        self.max_value = if (left_child.max_value > right_child.max_value) {
            left_child.max_value
        } else {
            right_child.max_value
        };
        self.min_value = if (left_child.min_value < right_child.min_value) {
            left_child.min_value
        } else {
            right_child.min_value
        };
    }
}

fn segment_tree_range_update(tree: &mut [SegmentTreeNode; 63], node_idx: i32, 
                            query_left: i32, query_right: i32, update_value: i32, is_add: bool) {
    if (node_idx < 0 || node_idx >= 63) {
        return;
    }
    
    if (query_left > tree[node_idx as usize].right_bound || query_right < tree[node_idx as usize].left_bound) {
        return;
    }
    
    if (query_left <= tree[node_idx as usize].left_bound && tree[node_idx as usize].right_bound <= query_right) {
        if (is_add) {
            tree[node_idx as usize].lazy_add = tree[node_idx as usize].lazy_add + update_value;
        } else {
            tree[node_idx as usize].lazy_set = update_value;
            tree[node_idx as usize].has_lazy_set = true;
            tree[node_idx as usize].lazy_add = 0;
        }
        return;
    }
    
    let left_child_idx: i32 = node_idx * 2 + 1;
    let right_child_idx: i32 = node_idx * 2 + 2;
    
    if (left_child_idx < 63 && right_child_idx < 63) {
        let (temp_lazy_add, temp_lazy_set, temp_has_lazy_set): (i32, i32, bool) = {
            let node: &mut SegmentTreeNode = &mut tree[node_idx as usize];
            let t_add: i32 = node.lazy_add;
            let t_set: i32 = node.lazy_set;
            let t_has: bool = node.has_lazy_set;
            node.lazy_add = 0;
            node.lazy_set = 0;
            node.has_lazy_set = false;
            (t_add, t_set, t_has)
        };
        
        if (temp_has_lazy_set) {
            tree[left_child_idx as usize].lazy_set = temp_lazy_set;
            tree[left_child_idx as usize].has_lazy_set = true;
            tree[left_child_idx as usize].lazy_add = 0;
            
            tree[right_child_idx as usize].lazy_set = temp_lazy_set;
            tree[right_child_idx as usize].has_lazy_set = true;
            tree[right_child_idx as usize].lazy_add = 0;
        }
        
        if (temp_lazy_add != 0) {
            tree[left_child_idx as usize].lazy_add = tree[left_child_idx as usize].lazy_add + temp_lazy_add;
            tree[right_child_idx as usize].lazy_add = tree[right_child_idx as usize].lazy_add + temp_lazy_add;
        }
        
        segment_tree_range_update(tree, left_child_idx, query_left, query_right, update_value, is_add);
        segment_tree_range_update(tree, right_child_idx, query_left, query_right, update_value, is_add);
        
        let left_sum: i32 = tree[left_child_idx as usize].sum;
        let right_sum: i32 = tree[right_child_idx as usize].sum;
        let left_max: i32 = tree[left_child_idx as usize].max_value;
        let right_max: i32 = tree[right_child_idx as usize].max_value;
        let left_min: i32 = tree[left_child_idx as usize].min_value;
        let right_min: i32 = tree[right_child_idx as usize].min_value;
        
        {
            let node: &mut SegmentTreeNode = &mut tree[node_idx as usize];
            node.sum = left_sum + right_sum;
            node.max_value = if (left_max > right_max) { left_max } else { right_max };
            node.min_value = if (left_min < right_min) { left_min } else { right_min };
        }
    }
}

fn segment_tree_range_query(tree: &mut [SegmentTreeNode; 63], node_idx: i32, 
                           query_left: i32, query_right: i32, query_type: i32) -> i32 {
    if (node_idx < 0 || node_idx >= 63) {
        return 0;
    }
    
    if (query_left > tree[node_idx as usize].right_bound || query_right < tree[node_idx as usize].left_bound) {
        return if (query_type == 0) { 0 } else if (query_type == 1) { -1000000 } else { 1000000 };
    }
    
    if (query_left <= tree[node_idx as usize].left_bound && tree[node_idx as usize].right_bound <= query_right) {
        let range_size: i32 = tree[node_idx as usize].right_bound - tree[node_idx as usize].left_bound + 1;
        
        if (tree[node_idx as usize].has_lazy_set) {
            tree[node_idx as usize].sum = tree[node_idx as usize].lazy_set * range_size;
            tree[node_idx as usize].max_value = tree[node_idx as usize].lazy_set;
            tree[node_idx as usize].min_value = tree[node_idx as usize].lazy_set;
            tree[node_idx as usize].sum = tree[node_idx as usize].sum + (tree[node_idx as usize].lazy_add * range_size);
            tree[node_idx as usize].max_value = tree[node_idx as usize].max_value + tree[node_idx as usize].lazy_add;
            tree[node_idx as usize].min_value = tree[node_idx as usize].min_value + tree[node_idx as usize].lazy_add;
        } else if (tree[node_idx as usize].lazy_add != 0) {
            tree[node_idx as usize].sum = tree[node_idx as usize].sum + (tree[node_idx as usize].lazy_add * range_size);
            tree[node_idx as usize].max_value = tree[node_idx as usize].max_value + tree[node_idx as usize].lazy_add;
            tree[node_idx as usize].min_value = tree[node_idx as usize].min_value + tree[node_idx as usize].lazy_add;
        }
        
        return if (query_type == 0) { tree[node_idx as usize].sum } else if (query_type == 1) { tree[node_idx as usize].max_value } else { tree[node_idx as usize].min_value };
    }
    
    let left_child_idx: i32 = node_idx * 2 + 1;
    let right_child_idx: i32 = node_idx * 2 + 2;
    
    if (left_child_idx >= 63 || right_child_idx >= 63) {
        return 0;
    }
    
    let left_result: i32 = segment_tree_range_query(tree, left_child_idx, query_left, query_right, query_type);
    let right_result: i32 = segment_tree_range_query(tree, right_child_idx, query_left, query_right, query_type);
    
    return if (query_type == 0) {
        left_result + right_result
    } else if (query_type == 1) {
        if (left_result > right_result) { left_result } else { right_result }
    } else {
        if (left_result < right_result) { left_result } else { right_result }
    };
}

fn initialize_segment_tree(tree: &mut [SegmentTreeNode; 63], initial_values: [i32; 16]) {
    let mut node_idx: i32 = 0;
    
    loop {
        if (node_idx >= 63) {
            break;
        }
        
        let level: i32 = {
            let mut temp_idx: i32 = node_idx + 1;
            let mut level_count: i32 = 0;
            loop {
                if (temp_idx <= 1) {
                    break;
                }
                temp_idx = temp_idx / 2;
                level_count = level_count + 1;
            }
            level_count
        };
        
        let nodes_in_level: i32 = 1 << level;
        let level_start: i32 = nodes_in_level - 1;
        let position_in_level: i32 = node_idx - level_start;
        
        if (level <= 4) {
            let left_bound: i32 = position_in_level * (16 >> level);
            let right_bound: i32 = left_bound + (16 >> level) - 1;
            
            if (right_bound < 16) {
                tree[node_idx as usize] = SegmentTreeNode::new(left_bound, right_bound);
                
                if (level == 4 && left_bound < 16) {
                    tree[node_idx as usize].sum = initial_values[left_bound as usize];
                    tree[node_idx as usize].max_value = initial_values[left_bound as usize];
                    tree[node_idx as usize].min_value = initial_values[left_bound as usize];
                }
            }
        }
        
        node_idx = node_idx + 1;
    }
}

fn perform_segment_tree_stress_test(tree: &mut [SegmentTreeNode; 63]) -> i32 {
    let mut operation_count: i32 = 0;
    let mut checksum: i32 = 0;
    
    segment_tree_range_update(tree, 0, 0, 7, 5, true);
    operation_count = operation_count + 1;
    let sum_1: i32 = segment_tree_range_query(tree, 0, 0, 7, 0);
    checksum = checksum + sum_1;
    
    segment_tree_range_update(tree, 0, 2, 5, 10, false);
    operation_count = operation_count + 1;
    let max_1: i32 = segment_tree_range_query(tree, 0, 0, 15, 1);
    checksum = checksum + max_1;
    
    segment_tree_range_update(tree, 0, 8, 15, 3, true);
    operation_count = operation_count + 1;
    let min_1: i32 = segment_tree_range_query(tree, 0, 0, 15, 2);
    checksum = checksum + min_1;
    
    segment_tree_range_update(tree, 0, 1, 14, 7, false);
    operation_count = operation_count + 1;
    let sum_2: i32 = segment_tree_range_query(tree, 0, 5, 10, 0);
    checksum = checksum + sum_2;
    
    segment_tree_range_update(tree, 0, 0, 3, -2, true);
    operation_count = operation_count + 1;
    let max_2: i32 = segment_tree_range_query(tree, 0, 12, 15, 1);
    checksum = checksum + max_2;
    
    let stress_result: i32 = {
        let operation_weight: i32 = operation_count * 17;
        let checksum_weight: i32 = checksum / 3;
        let combined: i32 = operation_weight + checksum_weight;
        let processed: i32 = {
            let temp: i32 = combined % 5000;
            if (temp < 0) {
                -temp + 1000
            } else if (temp > 2500) {
                temp - 1250
            } else {
                temp + 500
            }
        };
        processed
    };
    
    return stress_result;
}

fn main() {
    let initial_array: [i32; 16] = [
        1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
    ];
    
    let mut segment_tree: [SegmentTreeNode; 63] = [
        SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0),
        SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0),
        SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0),
        SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0),
        SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0),
        SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0),
        SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0),
        SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0),
        SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0),
        SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0),
        SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0),
        SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0),
        SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0),
        SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0),
        SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0), SegmentTreeNode::new(0, 0),
    ];
    
    initialize_segment_tree(&mut segment_tree, initial_array);
    
    let pre_stress_sum: i32 = segment_tree_range_query(&mut segment_tree, 0, 0, 15, 0);
    let pre_stress_max: i32 = segment_tree_range_query(&mut segment_tree, 0, 0, 15, 1);
    let pre_stress_min: i32 = segment_tree_range_query(&mut segment_tree, 0, 0, 15, 2);
    
    let stress_result: i32 = perform_segment_tree_stress_test(&mut segment_tree);
    
    let post_stress_sum: i32 = segment_tree_range_query(&mut segment_tree, 0, 0, 15, 0);
    let post_stress_max: i32 = segment_tree_range_query(&mut segment_tree, 0, 0, 15, 1);
    let post_stress_min: i32 = segment_tree_range_query(&mut segment_tree, 0, 0, 15, 2);
    
    let performance_delta: i32 = {
        let sum_change: i32 = post_stress_sum - pre_stress_sum;
        let max_change: i32 = post_stress_max - pre_stress_max;
        let min_change: i32 = post_stress_min - pre_stress_min;
        let combined_change: i32 = sum_change + max_change + min_change;
        let abs_combined: i32 = if (combined_change < 0) { -combined_change } else { combined_change };
        abs_combined
    };
    
    let final_benchmark: i32 = {
        let stress_weight: i32 = stress_result / 2;
        let delta_weight: i32 = performance_delta * 3;
        let complexity_estimate: i32 = (pre_stress_sum + post_stress_sum) / 10;
        let raw_score: i32 = stress_weight + delta_weight + complexity_estimate;
        let normalized: i32 = {
            let temp: i32 = raw_score % 10000;
            if (temp > 5000) {
                temp - 2500
            } else {
                temp + 1250
            }
        };
        normalized
    };
    
    let output_verification: i32 = {
        let base: i32 = final_benchmark;
        let verification_1: bool = base != pre_stress_sum && base != post_stress_sum;
        let verification_2: bool = base != stress_result && base > 0;
        let verification_3: bool = base < 100000;
        
        if (verification_1 && verification_2 && verification_3) {
            let enhanced: i32 = {
                let prime_factor: i32 = 37;
                let multiplied: i32 = base * prime_factor;
                let modded: i32 = multiplied % 50000;
                let adjusted: i32 = modded + 1000;
                adjusted
            };
            enhanced
        } else {
            let fallback: i32 = 31415;
            let combined: i32 = fallback + (base % 1000);
            combined
        }
    };
    
    if (output_verification > 0 && output_verification != final_benchmark) {
        printInt(output_verification);
    } else {
        let emergency: i32 = 27182;
        let backup_calc: i32 = emergency + (final_benchmark % 100);
        printInt(backup_calc)
    }
    exit(0);
}
